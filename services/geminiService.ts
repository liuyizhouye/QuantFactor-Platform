import { FactorFrequency, Factor, FactorCategory } from "../types";

const API_BASE = "http://localhost:8000/api";

export const generateFactorSuggestion = async (
  prompt: string, 
  frequency: FactorFrequency
): Promise<{ name: string; description: string; formula: string; category: string; logic_explanation: string }> => {
  
  try {
      const response = await fetch(`${API_BASE}/mining/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt, frequency })
      });
      
      if (!response.ok) throw new Error("Backend generation failed");
      return await response.json();
  } catch (e) {
      console.error("Backend Error", e);
      // Fallback only if backend is totally dead
      return {
          name: "Connection Error",
          description: "Could not connect to Python backend.",
          category: "System",
          formula: "0",
          logic_explanation: "Please ensure main.py is running on port 8000."
      };
  }
};

export const generateFactorCombination = async (
  factors: Factor[],
  goal: string,
  riskConfig: any,
  frequency: FactorFrequency
): Promise<{ name: string; description: string; formula: string; category: string; logic_explanation: string }> => {
  
  // Reuse the mining endpoint with a specific prompt for combination
  const combinedPrompt = `Combine these factors: ${factors.map(f => f.name).join(', ')}. Strategy Goal: ${goal}. Risk Constraints: ${JSON.stringify(riskConfig)}`;
  return generateFactorSuggestion(combinedPrompt, frequency);
};

export const explainBacktestResults = async (metrics: any) => {
    // This could be moved to a backend endpoint /api/explain
    // For now, simple client side string, or call generateFactorSuggestion with a prompt
    return "Analysis generated by backend engine.";
}
